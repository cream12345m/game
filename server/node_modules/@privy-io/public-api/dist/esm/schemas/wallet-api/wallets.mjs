import{z as t}from"zod";import{InvalidInputError as e,PrivyErrorCode as i}from"@privy-io/api-base";import{Pagination as a}from"../api.mjs";import{SolanaWalletAddress as r,WalletAddress as o}from"../core.mjs";import{BaseTransactionResponse as n}from"../transaction.mjs";import{PrivateKeyExportInput as s}from"./export.mjs";import"bs58";import"libphonenumber-js/max";import"viem";const l=t.enum(["secp256k1","ed25519"]),d=t.string().regex(/^[mM]'?(\/\d+'?)*$/),c=t.literal("ECDSA"),g=t.literal("EdDSA"),p=t.union([c,g]),_=t.string().regex(/^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$/,"Chain ID must be a valid CAIP-2 chain ID, e.g. 'eip155:1'");let h=t.object({address:r.optional(),chain_type:t.literal("solana").optional(),wallet_id:t.string().optional()}),m=t.object({address:o.optional(),chain_type:t.literal("ethereum").optional(),wallet_id:t.string().optional()});const u=t.enum(["root","manager","delegated-actions"]).nullable(),b=t.object({method:t.literal("signTransaction"),params:t.object({transaction:t.string(),encoding:t.literal("base64")}).strict()}).merge(h).strict(),y=t.object({method:t.literal("signAndSendTransaction"),caip2:_,params:t.object({transaction:t.string(),encoding:t.literal("base64")}).strict()}).merge(h).strict(),j=t.object({method:t.literal("signMessage"),params:t.object({message:t.string(),encoding:t.literal("base64")}).strict()}).merge(h).strict(),v=t.string().startsWith("0x").refine((t=>!t.includes(".")),"Invalid hex string: must start with '0x' and not contain decimal points"),z=v.transform((t=>t));let f=t.number().int().nonnegative().safe({message:'Please use hex string prefixed with "0x" to represent large numbers (e.g. "0xDE0B6B3A7640000").'});const x=t.union([v,f],{invalid_type_error:"Invalid quantity: must be either a hex string starting with '0x' or a non-negative integer."}),w=t.object({from:o.optional(),to:o.optional(),chain_id:x.optional(),nonce:x.optional(),data:v.optional(),value:x.optional(),type:t.union([t.literal(0),t.literal(1),t.literal(2)]).optional(),gas_limit:x.optional(),gas_price:x.optional(),max_fee_per_gas:x.optional(),max_priority_fee_per_gas:x.optional()}).strict(),k=t.object({method:t.literal("eth_signTransaction"),params:t.object({transaction:w}).strict()}).merge(m).strict(),I=t.object({method:t.literal("eth_sendTransaction"),caip2:_,params:t.object({transaction:w}).strict()}).merge(m).strict(),A=t.object({message:t.string(),encoding:t.union([t.literal("utf-8"),t.literal("hex")])}).strict(),D=t.object({method:t.literal("personal_sign"),params:A}).merge(m).strict(),T=t.object({method:t.literal("secp256k1_sign"),params:t.object({hash:z}).strict()}).merge(m).strict(),P=t.object({method:t.literal("eth_sign7702Authorization"),params:t.object({contract:o,chain_id:x,nonce:x.optional()}).strict()}).merge(m).strict(),O=t.object({params:t.object({hash:z}).strict()}).strict(),S=t.record(t.string(),t.any()),U=t.record(t.array(t.object({name:t.string(),type:t.string()}))),W=t.object({method:t.literal("eth_signTypedData_v4"),params:t.object({typed_data:t.object({domain:S,types:U,message:t.record(t.string(),t.any()),primary_type:t.string()}).strict()}).strict()}).merge(m).strict(),q=t.object({address:t.string(),method:t.literal("exportPrivateKey"),params:s}).strict(),C=t.discriminatedUnion("method",[k,I,D,W,T,P]),E=t.discriminatedUnion("method",[b,y,j]),M=t.union([C,E,q]),B=t.object({method:t.literal("signTransaction"),data:t.object({signed_transaction:t.string(),encoding:t.literal("base64")})}),K=t.object({method:t.literal("signAndSendTransaction"),data:t.object({transaction_id:t.string().optional(),hash:t.string(),caip2:_}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}),L=t.object({method:t.literal("signMessage"),data:t.object({signature:t.string(),encoding:t.literal("base64")})}),N=t.object({method:t.literal("eth_signTransaction"),data:t.object({signed_transaction:t.string(),encoding:t.literal("rlp")})}),V=t.object({method:t.literal("eth_sendTransaction"),data:t.object({transaction_id:t.string().optional(),hash:t.string(),caip2:_,transaction_request:w.optional()}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}),$=t.object({method:t.literal("personal_sign"),data:t.object({signature:t.string(),encoding:t.literal("hex")})}),R=t.object({method:t.literal("secp256k1_sign"),data:t.object({signature:v,encoding:t.literal("hex")})});let Z=t.object({contract:o,chain_id:x,nonce:x,r:v,s:v,y_parity:t.number()});const F=t.object({method:t.literal("eth_sign7702Authorization"),data:t.object({authorization:Z}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}),G=t.object({method:t.literal("eth_signTypedData_v4"),data:t.object({signature:t.string(),encoding:t.literal("hex")})}),H=t.object({method:t.literal("exportPrivateKey"),data:s}),J=t.object({data:t.object({signature:v,encoding:t.literal("hex")}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}).strict(),Q=t.discriminatedUnion("method",[B,K,L,N,V,$,R,F,G,H]),X=t.object({display_name:t.string().optional(),public_key:t.string(),role:u.optional()}),Y=t.literal("cosmos"),tt=t.literal("stellar"),et=t.literal("sui"),it=t.literal("tron"),at=t.literal("bitcoin-segwit"),rt=t.union([Y,tt,et,it,at]),ot="curve_signing",nt=t.literal("curve_signing"),st=t.union([t.literal("solana"),t.literal("ethereum")]),lt=t.union([rt,st]),dt=t.object({id:t.string(),address:t.string(),public_key:t.string().optional(),created_at:t.number(),exported_at:t.number().nullable(),imported_at:t.number().nullable(),chain_type:lt,policy_ids:t.array(t.string()),authorization_threshold:t.number().optional(),additional_signers:t.array(t.object({signer_id:t.string().cuid2(),override_policy_ids:t.array(t.string()).optional()})),owner_id:t.string().cuid2().nullable()}),ct=t.string().cuid2(),gt=t.string(),pt=t.union([t.object({user_id:t.string().startsWith("did:privy:",{message:"user_id must start with did:privy:"})}).strict(),t.object({public_key:gt}).strict(),t.null()]),_t={owner:pt.optional(),owner_id:ct.nullable().optional()},ht=t.array(t.string().cuid2()).max(1,"Only one policy ID can be set").optional(),mt=t.array(t.object({signer_id:ct,override_policy_ids:ht}).strict()),ut=t.object({chain_type:lt,policy_ids:ht,authorization_key_ids:t.array(t.string()).optional(),authorization_threshold:t.number().optional(),additional_signers:mt.optional(),..._t}).strict(),bt=ut.refine((t=>{let e=void 0!==t.authorization_key_ids||void 0!==t.authorization_threshold,i=void 0!==t.additional_signers;return!e||!i}),"Please provide either additional_signers or authorization_key_ids, not both").refine((t=>void 0===t.authorization_threshold||t.authorization_threshold>=1&&t.authorization_key_ids&&t.authorization_threshold<=t.authorization_key_ids.length),{message:"If specified, authorization_threshold must be an integer between 1 and the length of authorization_key_ids."}).refine((t=>!t.owner||!t.owner_id),{message:"Only one of owner or owner_id can be provided."}).catch((t=>{throw new e(t.error.message,i.INVALID_DATA)})),yt=t.object({id:t.string(),chain_type:lt,address:t.string(),authorization_threshold:t.number().optional()}),jt=t.object({wallet_id:t.string({required_error:"Wallet ID must be provided",invalid_type_error:"Wallet ID is not a valid string"}).min(1)}).catch((({error:t})=>{throw new e(t.message,i.INVALID_DATA)})),vt=t.enum(["usdc","eth","pol"]),zt=t.enum(["sol"]),ft=t.enum([...vt.options,...zt.options]),xt=t.enum(["ethereum","arbitrum","base","linea","optimism","polygon","solana","zksync_era"]),wt=t.enum(["usd"]),kt=t.object({asset:t.union([ft,t.array(ft).max(10)]),chain:t.union([xt,t.array(xt).max(10)]),include_currency:wt.optional()}),It=t.object({chain:xt,asset:ft,raw_value:t.string(),raw_value_decimals:t.number(),display_values:t.record(t.union([ft,wt]),t.string())}),At=t.object({balances:t.array(It.refine((t=>t.asset in t.display_values),{message:"display_values must include the asset as a key",path:["display_values"]}))}),Dt=t.object({id:t.string()}),Tt=t.object({id:t.string(),display_name:t.string().nullable(),public_key:t.string(),role:u,created_at:t.number()}),Pt=t.object({id:t.string(),display_name:t.string().nullable(),public_key:t.string(),created_at:t.number()}),Ot=a.extend({chain_type:lt.optional(),user_id:t.string().optional()}).strict(),St=t.object({policy_ids:ht,authorization_key_ids:t.array(t.string()).optional(),authorization_threshold:t.number().optional(),additional_signers:mt.optional(),..._t}).strict().superRefine(((t,e)=>{Object.values(t).every((t=>void 0===t||""===t))&&e.addIssue({code:"custom",message:"At least one field must be provided"}),void 0!==t.owner&&void 0!==t.owner_id&&e.addIssue({code:"custom",message:"Only one of owner or owner_id can be provided."}),void 0!==t.authorization_threshold&&0!==t.authorization_threshold&&(t.authorization_threshold<0&&e.addIssue({code:"custom",path:["authorization_threshold"],message:"`authorization_threshold` must be non-negative if specified."}),void 0===t.authorization_key_ids&&e.addIssue({code:"custom",path:["authorization_key_ids"],message:"An array of `authorization_key_ids` must be provided for a non-zero `authorization_threshold`."}),t.authorization_key_ids&&t.authorization_threshold>t.authorization_key_ids.length&&e.addIssue({code:"custom",path:["authorization_threshold"],message:"`authorization_threshold` must be non-negative if specified."}))})),Ut=a.extend({chain:t.literal("base"),asset:t.union([ft,t.array(ft).max(2)])}).strict(),Wt=t.object({type:t.literal("transfer_sent"),sender:t.string(),sender_privy_user_id:t.string().nullable(),recipient:t.string(),recipient_privy_user_id:t.string().nullable()}).strict().merge(It),qt=t.object({type:t.literal("transfer_received"),sender:t.string(),sender_privy_user_id:t.string().nullable(),recipient:t.string(),recipient_privy_user_id:t.string().nullable()}).strict().merge(It),Ct=t.discriminatedUnion("type",[Wt,qt]),Et=n.extend({details:Ct.nullable()}),Mt=Et.extend({privy_transaction_id:t.string(),wallet_id:t.string()}),Bt=t.object({transactions:t.array(Mt),next_cursor:t.string().nullable()});export{mt as AdditionalSignerInput,ft as Asset,It as AssetAmountDetails,Tt as AuthorizationKeyDashboardResponse,Pt as AuthorizationKeyResponse,u as AuthorizationKeyRole,wt as BalanceFiatCurrency,ut as BaseWalletApiCreateInput,at as BitcoinSegwit,_ as CAIP2,ot as CURVE_SIGNING,xt as ChainNameInput,lt as ChainType,Y as Cosmos,rt as CurveSigningChainTypes,nt as CurveSigningLiteral,l as CurveType,c as ECDSA,g as EdDSA,vt as EthereumAsset,st as FirstClassChainTypes,d as HDPath,z as Hash,v as Hex,ct as KeyQuorumId,pt as OwnerInput,_t as OwnerInputFields,gt as P256PublicKey,ht as PolicyInput,Mt as PrivyTransactionResponseWithDetails,x as Quantity,p as SigningAlgorithm,zt as SolanaAsset,tt as Stellar,et as Sui,Ct as TransactionDetail,Et as TransactionResponseWithDetails,qt as TransferReceivedTransactionDetail,Wt as TransferSentTransactionDetail,it as Tron,S as TypedDataDomainInputParams,U as TypedDataTypesInputParams,w as UnsignedEthereumTransaction,bt as WalletApiCreateInput,yt as WalletApiCreateResponse,D as WalletApiEthereumPersonalSignRpcInput,A as WalletApiEthereumPersonalSignRpcInputParams,$ as WalletApiEthereumPersonalSignRpcResponse,C as WalletApiEthereumRpcInput,T as WalletApiEthereumSecp256k1SignRpcInput,R as WalletApiEthereumSecp256k1SignRpcResponse,I as WalletApiEthereumSendTransactionRpcInput,V as WalletApiEthereumSendTransactionRpcResponse,P as WalletApiEthereumSign7702AuthorizationRpcInput,F as WalletApiEthereumSign7702AuthorizationRpcResponse,k as WalletApiEthereumSignTransactionRpcInput,N as WalletApiEthereumSignTransactionRpcResponse,W as WalletApiEthereumSignTypedDataRpcInput,G as WalletApiEthereumSignTypedDataRpcResponse,q as WalletApiExportPrivateKeyRpcInput,H as WalletApiExportPrivateKeyRpcResponse,O as WalletApiRawSignInput,J as WalletApiRawSignResponse,X as WalletApiRegisterAuthorizationKeyInput,Dt as WalletApiRevokeAuthorizationKeyInput,M as WalletApiRpcInput,Q as WalletApiRpcResponse,E as WalletApiSolanaRpcInput,y as WalletApiSolanaSignAndSendTransactionRpcInput,K as WalletApiSolanaSignAndSendTransactionRpcResponse,j as WalletApiSolanaSignMessageRpcInput,L as WalletApiSolanaSignMessageRpcResponse,b as WalletApiSolanaSignTransactionRpcInput,B as WalletApiSolanaSignTransactionRpcResponse,kt as WalletGetBalanceInput,At as WalletGetBalanceResponse,Ut as WalletGetTransactionsInput,Bt as WalletGetTransactionsResponse,jt as WalletIdFromPath,dt as WalletResponse,St as WalletUpdateInput,Ot as WalletsSearchInput};
